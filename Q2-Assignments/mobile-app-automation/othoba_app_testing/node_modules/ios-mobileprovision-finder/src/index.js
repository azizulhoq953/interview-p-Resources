"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cert = exports.provision = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const plist = require("plist");
const child_process_1 = require("child_process");
const sec_find_id = require("./parsers/security-find-identity");
const sec_find_cert = require("./parsers/security-find-certificate");
var provision;
(function (provision_1) {
    const nodefs = { readdirSync: fs_1.readdirSync, readFileSync: fs_1.readFileSync };
    const defaultPath = process && process.env && process.env.HOME
        ? (0, path_1.join)(process.env.HOME, "Library/MobileDevice/Provisioning Profiles/")
        : ".";
    const plistStartToken = Buffer.from("<plist", "ascii");
    const plistEndToken = Buffer.from("</plist>", "ascii");
    function parseAppIdSelector(id) {
        const teamIdDot = id.indexOf(".");
        const isWildcard = id.substring(id.length - 2) === ".*";
        const team = id.substring(0, teamIdDot);
        const prefixStart = teamIdDot + 1;
        const prefixEnd = isWildcard ? id.length - 2 : id.length;
        const identifier = prefixStart < prefixEnd ? id.substring(prefixStart, prefixEnd) : "";
        const test = isWildcard
            ? (testId) => {
                return testId.substring(0, identifier.length) == identifier;
            }
            : (testId) => {
                return testId === identifier;
            };
        return { team, identifier, isWildcard, test };
    }
    /**
     * Read all provisioning profiles.
     */
    function read({ readdirSync, readFileSync, } = nodefs) {
        return readdirSync(defaultPath)
            .filter((file) => (0, path_1.extname)(file) === ".mobileprovision")
            .map((file) => {
            try {
                const filePath = (0, path_1.join)(defaultPath, file);
                return readFromFile(filePath, { readdirSync, readFileSync });
            }
            catch (e) {
                return null;
            }
        })
            .filter((p) => !!p);
    }
    provision_1.read = read;
    /**
     * Reads a provisioning profile.
     */
    function readFromFile(filePath, { readdirSync, readFileSync } = nodefs) {
        try {
            const fileContent = readFileSync(filePath);
            const plistStart = fileContent.indexOf(plistStartToken);
            const plistEnd = fileContent.indexOf(plistEndToken) + plistEndToken.length;
            if (plistStart >= 0 && plistStart < plistEnd) {
                const plistContent = fileContent.toString("utf-8", plistStart, plistEnd);
                const plistJson = plist.parse(plistContent);
                if (plistJson.DeveloperCertificates) {
                    plistJson.DeveloperCertificates = plistJson.DeveloperCertificates.map((c) => c.toString("base64"));
                }
                if (plistJson.ProvisionsAllDevices) {
                    plistJson.Type = "Enterprise";
                }
                else if (plistJson.ProvisionedDevices &&
                    plistJson.ProvisionedDevices.length) {
                    const entitlements = plistJson.Entitlements;
                    if (entitlements["get-task-allow"]) {
                        plistJson.Type = "Development";
                    }
                    else {
                        plistJson.Type = "AdHoc";
                    }
                }
                else {
                    plistJson.Type = "Distribution";
                }
                return plistJson;
            }
            else {
                return null;
            }
        }
        catch (e) {
            return null;
        }
    }
    provision_1.readFromFile = readFromFile;
    function select(mobileprovisions, { ExpirationDate = new Date(), TeamName, AppId, ProvisionedDevices, Type, Certificates, Unique = true, }) {
        let filter = () => true;
        const both = (a, b) => (provision) => a(provision) && b(provision);
        const chain = (next) => (filter = both(filter, next));
        chain((provision) => provision.ExpirationDate >= ExpirationDate);
        TeamName && chain((provision) => provision.TeamName === TeamName);
        AppId &&
            chain((provision) => parseAppIdSelector(provision.Entitlements["application-identifier"]).test(AppId));
        ProvisionedDevices &&
            chain((provision) => provision.ProvisionsAllDevices ||
                ProvisionedDevices.every((required) => provision.ProvisionedDevices &&
                    provision.ProvisionedDevices.some((provisioned) => required === provisioned)));
        Type && chain((provision) => provision.Type === Type);
        if (Certificates) {
            const validPemHeads = {};
            Certificates.forEach((c) => (validPemHeads[c.pem.substr(0, 60)] = true));
            chain((provision) => provision.DeveloperCertificates.some((dc) => validPemHeads[dc.substr(0, 60)]));
        }
        filter = ((test) => (provision) => {
            try {
                return test(provision);
            }
            catch (e) {
                return false;
            }
        })(filter);
        const eligible = [];
        const nonEligible = [];
        mobileprovisions.forEach((prov) => {
            if (filter(prov)) {
                eligible.push(prov);
            }
            else {
                nonEligible.push(prov);
            }
        });
        if (Unique) {
            const eligibleMap = {};
            const nonEligibleMap = {};
            eligible.forEach((next) => {
                const prev = eligibleMap[next.Name];
                if (!prev || prev.CreationDate < next.CreationDate) {
                    eligibleMap[next.Name] = next;
                }
            });
            nonEligible.forEach((next) => {
                const prev = nonEligibleMap[next.Name];
                if (!eligibleMap[next.Name] &&
                    (!prev || prev.CreationDate < next.CreationDate)) {
                    nonEligibleMap[next.Name] = next;
                }
            });
            return {
                eligible: Object.keys(eligibleMap).map((name) => eligibleMap[name]),
                nonEligible: Object.keys(nonEligibleMap).map((name) => nonEligibleMap[name]),
            };
        }
        else {
            return { eligible, nonEligible };
        }
    }
    provision_1.select = select;
})(provision = exports.provision || (exports.provision = {}));
var cert;
(function (cert_1) {
    /**
     * Read all codesigning sertificates using the 'security' tool from the default keychain search list.
     */
    function read() {
        const findIdentity = (0, child_process_1.execSync)("security find-identity -p codesigning").toString();
        const certIdentities = sec_find_id.parse(findIdentity);
        const findCertificate = (0, child_process_1.execSync)("security find-certificate -apZ").toString();
        const certHashes = sec_find_cert.parse(findCertificate);
        const hashToPem = {};
        certHashes.forEach((certHash) => (hashToPem[certHash.hash] = certHash.pem));
        const hashToIsValid = {};
        certIdentities.valid.forEach((id) => (hashToIsValid[id.hash] = true));
        const certs = certIdentities.matching
            .map((cert) => ({
            hash: cert.hash,
            name: cert.name,
            issue: cert.issue,
            isValid: hashToIsValid[cert.hash] && !cert.issue,
            pem: hashToPem[cert.hash],
        }))
            .reduce((acc, cert) => (cert.isValid ? acc.valid : acc.invalid).push(cert) && acc, { valid: [], invalid: [] });
        return certs;
    }
    cert_1.read = read;
})(cert = exports.cert || (exports.cert = {}));
//# sourceMappingURL=index.js.map